Порівняльний аналіз алгоритмів сортування
Опис
У цьому проекті виконано порівняльний аналіз трьох алгоритмів сортування: сортування вставками (Insertion Sort), сортування злиттям (Merge Sort) та Timsort. Метою дослідження було емпірично перевірити їхні теоретичні оцінки складності, порівняти час виконання на різних наборах даних і зробити висновки щодо їхньої ефективності.

Алгоритми
1. Алгоритм сортування вставками (Insertion Sort)
Складність: O(n^2) у середньому та найгіршому випадку.

Принцип роботи: алгоритм будує відсортовану послідовність, поступово вставляючи елементи з невідсортованої частини масиву у відповідне місце в відсортованій частині.

2. Алгоритм сортування злиттям (Merge Sort)
Складність: O(n log n) у середньому та найгіршому випадку.

Принцип роботи: рекурсивно розбиває масив на дві половини, сортує кожну частину окремо, а потім зливає відсортовані частини.

3. Timsort
Складність: O(n log n) у середньому та найгіршому випадку.

Принцип роботи: поєднує сортування вставками для малих підмасивів та сортування злиттям для великих підмасивів. Вбудований у Python алгоритм для функцій sorted() та sort().

Порівняння алгоритмів
Алгоритми були протестовані на наборах даних різних розмірів (100, 1000, 10000 елементів), і для кожного було виміряно час виконання за допомогою модуля timeit.

Набори даних:
Випадкові числа
Частково відсортовані масиви
Повністю відсортовані масиви
Результати (приклад):
Розмір масиву	Insertion Sort	Merge Sort	    Timsort
100	            0.0012 секунд	0.0009 секунд	0.0005 секунд
1000	        0.0923 секунд	0.0091 секунд	0.0076 секунд
10000	        13.45 секунд	0.12 секунд	    0.098 секунд
Висновки
Сортування вставками ефективне для невеликих або майже відсортованих масивів, але втрачає ефективність на великих наборах даних через квадратичну складність.
Сортування злиттям показує стабільний час виконання на будь-яких наборах даних завдяки логарифмічній складності, проте програє Timsort на частково відсортованих масивах.
Timsort поєднує переваги двох методів, завдяки чому є найбільш ефективним для великих масивів та майже відсортованих даних. Це підтверджує доцільність використання вбудованих алгоритмів Python у більшості випадків.
Висновки
Емпіричні результати підтверджують теоретичну оцінку складності алгоритмів. Поєднання сортування злиттям і сортування вставками в Timsort робить його значно ефективнішим, особливо для реальних сценаріїв, коли масиви частково відсортовані або мають неоднорідну структуру. Це пояснює, чому саме цей алгоритм обрано в Python для вбудованих функцій сортування.